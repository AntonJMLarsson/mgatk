from os.path import join
import os
import subprocess
import shutil
import pysam

configfile: config["cfp"]     
           
# Parse the configuration variables
indir = config["input_directory"]
outdir = config["output_directory"]
name = config["name"]
script_dir = config["script_dir"]

mito_genome = config["mito_genome"]
mito_length = config["mito_length"]
fasta_file = config["fasta_file"]

keep_duplicates = config["keep_duplicates"]
proper_paired = config["proper_paired"]
skip_indels = config["skip_indels"]

read_qual = config["read_qual"]

clipL = config["clipl"]
clipR = config["clipr"]
NHmax = config["NHmax"]
NMmax = config["NMmax"]

detailed_calls = config["detailed_calls"]

# Software paths
bcftools = "bcftools"
java = "java"
R = "R"
samtools = "samtools"
tabix = "tabix"
python = "python"

# Script calls
filtclip_py = script_dir + "/bin/filterClipBam.py"
detailedcall_py = script_dir + "/bin/detailedCalls.py"
MarkDuplicatesCall = java + " -Xmx4000m  -jar " + script_dir + "/bin/MarkDuplicates.jar"

# A Snakemake regular expression matching the bam files that were all aligned
SAMPLES, = glob_wildcards(join(outdir, ".internal/samples/{sample}.bam.txt"))

bamtxtin = '{sample}.bam.txt'


rule all:
	input:
		outdir + "/final/" + name + ".depthTable.txt",
		outdir + "/final/" + name + ".allCalls.txt.gz",
		outdir + "/qc/detailed/detailed.run.txt"

rule filter_sort:
	input:
		txtin = join(outdir + "/.internal/samples", bamtxtin)
	output:
		bam = outdir + "/temp/ready_bam/{sample}.qc.bam",
		bai = outdir + "/temp/ready_bam/{sample}.qc.bam.bai"
	threads: 1
	run:
		with open(input.txtin) as f: bamfilepath = f.read()
		rmlog = output.bam.replace(".qc.bam", ".rmdups.logs").replace("/temp/ready_bam/", "/logs/rmdupslogs/")
		filtlog = output.bam.replace(".qc.bam", ".filter.logs").replace("/temp/ready_bam/", "/logs/filterlogs/")
		temp_bam0 = output.bam.replace(".qc.bam", ".temp0.bam").replace("/temp/ready_bam/", "/temp/temp_bam/")
		temp_bam1 = output.bam.replace(".qc.bam", ".temp1.bam").replace("/temp/ready_bam/", "/temp/temp_bam/")
		
		pycall = " ".join([python, filtclip_py, bamfilepath, filtlog, clipL, "-"+clipR, mito_genome, NHmax, NMmax])
		
		if(len(proper_paired) > 0):
			pycallout = pycall + proper_paried + " > " + temp_bam0
		else:
			pycallout = pycall+ " > " + temp_bam0
			
		os.system(pycallout)
		
		# Sort the filtered bam file
		pysam.sort("-o", temp_bam1, temp_bam0)
		pysam.index(temp_bam1)
		
		if not keep_duplicates:
			mdc_long = MarkDuplicatesCall + " INPUT="+temp_bam1+" OUTPUT="+output.bam+" METRICS_FILE="+rmlog+" REMOVE_DUPLICATES=true VALIDATION_STRINGENCY=SILENT"
			os.system(mdc_long)
		else: # just move the previous output
			os.system("mv " + temp_bam1 + " " + output.bam)
			os.system("mv " + temp_bam1 + ".bai " + output.bai)
		pysam.index(output.bam)

rule get_depth_bq_baq:
	input:
		bam = outdir + "/temp/ready_bam/{sample}.qc.bam"
	output:
		depth = outdir + "/qc/depth/{sample}.Q0.depth.txt", 
		baq = outdir + "/qc/BAQ/{sample}.Q0.BAQ.txt", 
		bq = outdir + "/qc/BQ/{sample}.Q0.BQ.txt"
	threads: 1
	run:
		bamfilepath = input.bam
		
		# Depth
		os.system(samtools + " depth "+bamfilepath+" | awk '{sum+=$3} END {print sum/"+str(mito_length)+"}' > " + output.depth)
		
		# BAQ
		baq_vcf_gz = output.baq.replace(".Q0.BAQ.txt", ".Q0.BAQ.vcf.gz").replace("/qc/BAQ/", "/temp/vcf/")
		stc = samtools + " mpileup -d8000 -f "+fasta_file+" -r "+mito_genome+" -Q0 -t AD,ADF,ADR "+skip_indels+"-v "+bamfilepath+" > " + baq_vcf_gz
		os.system(stc)
		os.system(tabix + " " + baq_vcf_gz)
		bcc = bcftools+" query -f '[%POS\tINFO/%I16\n]' "+baq_vcf_gz+" | sed -e 's/INFO\///g' -e 's/,/\t/g' > " + output.baq
		os.system(bcc)
		
		# BQ
		bq_vcf_gz = output.bq.replace(".Q0.BQ.txt", ".Q0.BQ.vcf.gz").replace("/qc/BQ/", "/temp/vcf/")
		stc2 = samtools + " mpileup -d8000 -f "+fasta_file+" -r "+mito_genome+" -Q0 -B -t AD,ADF,ADR "+skip_indels+"-v "+bamfilepath+" > " + bq_vcf_gz
		os.system(stc2)
		os.system(tabix + " " + bq_vcf_gz)
		bcc2 = bcftools+" query -f '[%POS\tINFO/%I16\n]' "+bq_vcf_gz+" | sed -e 's/INFO\///g' -e 's/,/\t/g' > " + output.bq
		os.system(bcc2)

rule detailed_variant_calls:
	input:
		expand(outdir + "/temp/ready_bam/{sample}.qc.bam", sample=SAMPLES)
	output:
		o1 = temp(outdir + "/qc/detailed/{sample}.detailed.txt"),
		out = outdir + "/qc/detailed/{sample}.detailed.txt.gz"
	run:
		if(detailed_calls == "True"):
			pycall0 = " ".join([python, detailedcall_py, input[0], output.o1, fasta_file])
			os.system(pycall0)
			os.system("gzip -c " + output.o1 + " > " + output.out)
		else:
			with open(output.out , 'wb') as outfile:
				outfile.write(" ".encode())
				
rule gather_variant_calls:
	input:
		expand(outdir + "/qc/detailed/{sample}.detailed.txt.gz", sample=SAMPLES)
	output:
		out = outdir + "/qc/detailed/detailed.run.txt"
	run:
		if(detailed_calls == "True"):
			with open(output.out , 'w') as outfile:
				outfile.write("Detailed variant calls complete. \n")
		else:
			with open(output.out , 'w') as outfile:
				outfile.write("Detailed variant calls not chosen. \n")
		
			
rule call_variants:
	input:
		expand(outdir + "/temp/ready_bam/{sample}.qc.bam", sample=SAMPLES)
	output:
		bamlist = temp(outdir + "/temp/vcf/allBamSamples.txt"),
		vcf = temp(outdir + "/temp/vcf/All.SNPs.vcf.gz"),
		mnpvcf = temp(outdir + "/temp/vcf/All.SNPs.MNP.vcf.gz"),
		mnptxt = outdir + "/temp/vcf/All.SNPs.MNP.txt",
		gzcall = outdir + "/final/" + name + ".allCalls.txt.gz"
		
	run:
		# Make text file of all the bams
		with open(output.bamlist, 'w') as o:
			for i in input:
				o.write(i + "\n")

		stc1 = samtools + " mpileup -d8000 -f "+fasta_file+" -r "+mito_genome+" -Q"+read_qual+" -t AD,ADF,ADR "+skip_indels+" -b "+output.bamlist+" -v > " + output.vcf
		os.system(stc1)
		
		bcc1 = bcftools + " norm -m-both " + output.vcf + " > " + output.mnpvcf
		os.system(bcc1)
		
		bcc2 = bcftools + " query -f '[%CHROM\t%POS\t%ALT\t%SAMPLE\tINFO/%AD\n]' " +  output.mnpvcf + " > " + output.mnptxt
		os.system(bcc2)
		
		outsed = (outdir + "/temp/ready_bam/").replace("/", "\/")
		finalcmd = '''cat '''+output.mnptxt+''' | sed -e 's/INFO\///g' -e 's/,/\t/g' | awk '$3 != "<*>" && $6 != "0" {print $2"\t"$3"\t"$4"\t"$6}' | sed -e 's/INFO\///g' -e 's/''' +outsed + '''//g' | sed -e 's/INFO\///g' -e 's/.qc.bam//g' | gzip > ''' + output.gzcall
		os.system(finalcmd)
		
rule make_depth_table:
	input:
		expand(outdir + "/qc/depth/{sample}.Q0.depth.txt", sample=SAMPLES)
	output:
		outdir + "/final/" + name + ".depthTable.txt"
	threads: 1
	run: 
		with open(output[0], 'w') as f:
			for i in input:
				sample = i.replace(outdir+ "/qc/depth/", '').replace(".Q0.depth.txt", '')
				result = subprocess.run(['cat', i], stdout=subprocess.PIPE)
				f.write(sample + " " + result.stdout.strip().decode("utf-8") + "\n")
