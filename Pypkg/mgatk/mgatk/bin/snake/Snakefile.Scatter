from os.path import join
import os
import subprocess
import shutil
import pysam

configfile: config["cfp"]     
           
# Parse the configuration variables
indir = config["input_directory"]
outdir = config["output_directory"]
read_qual = config["read_qual"]
mito_genome = config["mito_genome"]
mito_length = config["mito_length"]
fasta_file = config["fasta_file"]
script_dir = config["script_dir"]
skip_indels = config["skip_indels"]
name = config["name"]
keep_duplicates = config["keep_duplicates"]
filtered_sorted = config["filtered_sorted"]
clipL = config["clipl"]
clipR = config["clipr"]
filter_reads = config["filter_reads"]
proper_paired = config["proper_paired"]

# Software paths
bcftools = "bcftools"
java = "java"
samtools = "samtools"
tabix = "tabix"
python = "python"

# Script calls
filtclip_py = script_dir + "/bin/filterClipBam.py"
MarkDuplicatesCall = java + " -Xmx4000m  -jar " + script_dir + "/bin/MarkDuplicates.jar"

# A Snakemake regular expression matching the bam files that were all aligned
SAMPLES, = glob_wildcards(join(outdir, ".internal/samples/{sample}.bam.txt"))

bamtxtin = '{sample}.bam.txt'


rule all:
	input:
		outdir + "/final/" + name + ".depthTable.txt",
		outdir + "/final/" + name + ".allCalls.txt.gz"

rule filter_sort:
	input:
		txtin = join(outdir + "/.internal/samples", bamtxtin)
	output:
		bam = outdir + "/temp/ready_bam/{sample}.qc.bam",
		bai = outdir + "/temp/ready_bam/{sample}.qc.bam.bai"
	threads: 1
	run:
		rmlog = output.bam.replace(".qc.bam", ".rmdups.logs").replace("/temp/ready_bam/", "/logs/rmdupslogs/")
		with open(input.txtin) as f: bamfilepath = f.read()
		sam_header = output.bam.replace(".qc.bam", ".header.sam").replace("/temp/ready_bam/", "/temp/temp_bam/")
		temp_bam0 = output.bam.replace(".qc.bam", ".temp0.bam").replace("/temp/ready_bam/", "/temp/temp_bam/")
		temp_bam1 = output.bam.replace(".qc.bam", ".temp1.bam").replace("/temp/ready_bam/", "/temp/temp_bam/")
		temp_bam2 = output.bam.replace(".qc.bam", ".temp2.bam").replace("/temp/ready_bam/", "/temp/temp_bam/")
		
		
		# User likes the .bam files the way they are though we may need to filter duplicates
		if(filtered_sorted):
			if(keep_duplicates):
				if(len(filter_reads)==0):
					shutil.copyfile(bamfilepath, output.bam)
				else:
					os.system(samtools + " view -H "+bamfilepath+ " > " + sam_header)
					os.system(samtools + " view " + bamfilepath + " " + filter_reads + " | cat " + sam_header + " - | "+samtools+" view -b - > " + output.bam)
			else:
				if(len(filter_reads) == 0):
					mdc_long = MarkDuplicatesCall + " INPUT="+bamfilepath+" OUTPUT="+output.bam+" METRICS_FILE="+rmlog+" REMOVE_DUPLICATES=true VALIDATION_STRINGENCY=SILENT"
					os.system(mdc_long)
				else:
					prepbam = output.bam.replace(".qc.bam", ".prep.bam").replace("/temp/ready_bam/", "/temp/temp_bam/")
					os.system(samtools + " view -H "+bamfilepath+ " > " + sam_header)
					os.system(samtools + " view " + bamfilepath + " " + filter_reads + " | cat " + sam_header + " - | "+samtools+" view -b - > " + temp_bam1)
					pysam.sort("-o", temp_bam2, temp_bam1)
					pysam.index(temp_bam2)
					mdc_long = MarkDuplicatesCall + " INPUT="+temp_bam2+" OUTPUT="+prepbam+" METRICS_FILE="+rmlog+" REMOVE_DUPLICATES=true VALIDATION_STRINGENCY=SILENT"
					os.system(mdc_long)
					pysam.sort("-o", output.bam, prepbam)
					
		# Do some filtering, clipping, and sorting
		else:
			prepbam = output.bam.replace(".qc.bam", ".prep.bam").replace("/temp/ready_bam/", "/temp/temp_bam/")
			if(keep_duplicates):
				if(len(filter_reads)==0):
					fcb_call = python + " " + filtclip_py + " " + bamfilepath + " " + clipL + " -" + clipR + " " + mito_genome + " | " + samtools + " sort -n - | " + samtools + " fixmate - " + prepbam
					os.system(fcb_call)
				else:
					fcb_call = python + " " + filtclip_py + " " + bamfilepath + " " + clipL + " -" + clipR + " " + mito_genome + " | " + samtools + " sort -n - | " + samtools + " fixmate - " + temp_bam0
					os.system(fcb_call)
					os.system(samtools + " view -H "+temp_bam0+ " > " + sam_header)
					os.system(samtools + " view " + temp_bam0 + " " + filter_reads + " | cat " + sam_header + " - | "+samtools+" view -b - > " + temp_bam1)
					pysam.sort("-o", prepbam, temp_bam1)
					# Keep duplicates -- nothing to add here
			else:
				if(len(filter_reads)==0):
					filtbam = output.bam.replace(".qc.bam", ".filt.bam").replace("/temp/ready_bam/", "/temp/temp_bam/")
					fcb_call = python + " " + filtclip_py + " " + bamfilepath + " " + clipL + " -" + clipR + " " + mito_genome + " | " + samtools + " sort -n - | " + samtools + " fixmate - " + filtbam
					os.system(fcb_call)
				
					rmdupbam = filtbam.replace(".filt.bam", ".rmdup.bam")
					pysam.sort("-o", rmdupbam, filtbam)
					mdc_long = MarkDuplicatesCall + " INPUT="+rmdupbam+" OUTPUT="+prepbam+" METRICS_FILE="+rmlog+" REMOVE_DUPLICATES=true VALIDATION_STRINGENCY=SILENT"
					os.system(mdc_long)	
				else:
					fcb_call = python + " " + filtclip_py + " " + bamfilepath + " " + clipL + " -" + clipR + " " + mito_genome + " | " + samtools + " sort -n - | " + samtools + " fixmate - " + temp_bam0
					os.system(fcb_call)
					os.system(samtools + " view -H "+temp_bam0+ " > " + sam_header)
					os.system(samtools + " view " + temp_bam0 + " " + filter_reads + " | cat " + sam_header + " - | "+samtools+" view -b - > " + temp_bam1)
					pysam.sort("-o", temp_bam2, temp_bam1)
					pysam.index(temp_bam2)
					mdc_long = MarkDuplicatesCall + " INPUT="+temp_bam2+" OUTPUT="+prepbam+" METRICS_FILE="+rmlog+" REMOVE_DUPLICATES=true VALIDATION_STRINGENCY=SILENT"
					os.system(mdc_long)
					
			pysam.sort("-o", output.bam, prepbam)
		
		# No matter what, prepare the index	
		pysam.index(output.bam)

rule get_depth_bq_baq:
	input:
		bam = outdir + "/temp/ready_bam/{sample}.qc.bam"
	output:
		depth = outdir + "/qc/depth/{sample}.Q0.depth.txt", 
		baq = outdir + "/qc/BAQ/{sample}.Q0.BAQ.txt", 
		bq = outdir + "/qc/BQ/{sample}.Q0.BQ.txt"
	threads: 1
	run:
		bamfilepath = input.bam
		
		# Depth
		os.system(samtools + " depth "+bamfilepath+" | awk '{sum+=$3} END {print sum/"+str(mito_length)+"}' > " + output.depth)
		
		# BAQ
		baq_vcf_gz = output.baq.replace(".Q0.BAQ.txt", ".Q0.BAQ.vcf.gz").replace("/qc/BAQ/", "/temp/vcf/")
		stc = samtools + " mpileup -d8000 -f "+fasta_file+" -r "+mito_genome+" -Q0 -t AD,ADF,ADR "+skip_indels+"-v "+bamfilepath+" > " + baq_vcf_gz
		os.system(stc)
		os.system(tabix + " " + baq_vcf_gz)
		bcc = bcftools+" query -f '[%POS\tINFO/%I16\n]' "+baq_vcf_gz+" | sed -e 's/INFO\///g' -e 's/,/\t/g' > " + output.baq
		os.system(bcc)
		
		# BQ
		bq_vcf_gz = output.bq.replace(".Q0.BQ.txt", ".Q0.BQ.vcf.gz").replace("/qc/BQ/", "/temp/vcf/")
		stc2 = samtools + " mpileup -d8000 -f "+fasta_file+" -r "+mito_genome+" -Q0 -B -t AD,ADF,ADR "+skip_indels+"-v "+bamfilepath+" > " + bq_vcf_gz
		os.system(stc2)
		os.system(tabix + " " + bq_vcf_gz)
		bcc2 = bcftools+" query -f '[%POS\tINFO/%I16\n]' "+bq_vcf_gz+" | sed -e 's/INFO\///g' -e 's/,/\t/g' > " + output.bq
		os.system(bcc2)

rule call_variants:
	input:
		expand(outdir + "/temp/ready_bam/{sample}.qc.bam", sample=SAMPLES)
	output:
		bamlist = temp(outdir + "/temp/vcf/allBamSamples.txt"),
		vcf = temp(outdir + "/temp/vcf/All.SNPs.vcf.gz"),
		mnpvcf = temp(outdir + "/temp/vcf/All.SNPs.MNP.vcf.gz"),
		mnptxt = outdir + "/temp/vcf/All.SNPs.MNP.txt",
		gzcall = outdir + "/final/" + name + ".allCalls.txt.gz"
		
	run:
		# Make text file of all the bams
		with open(output.bamlist, 'w') as o:
			for i in input:
				o.write(i + "\n")

		stc1 = samtools + " mpileup -d8000 -f "+fasta_file+" -r "+mito_genome+" -Q"+read_qual+" -t AD,ADF,ADR "+skip_indels+" -b "+output.bamlist+" -v > " + output.vcf
		os.system(stc1)
		
		bcc1 = bcftools + " norm -m-both " + output.vcf + " > " + output.mnpvcf
		os.system(bcc1)
		
		bcc2 = bcftools + " query -f '[%CHROM\t%POS\t%ALT\t%SAMPLE\tINFO/%AD\n]' " +  output.mnpvcf + " > " + output.mnptxt
		os.system(bcc2)
		
		outsed = (outdir + "/temp/ready_bam/").replace("/", "\/")
		finalcmd = '''cat '''+output.mnptxt+''' | sed -e 's/INFO\///g' -e 's/,/\t/g' | awk '$3 != "<*>" && $6 != "0" {print $2"\t"$3"\t"$4"\t"$6}' | sed -e 's/INFO\///g' -e 's/''' +outsed + '''//g' | sed -e 's/INFO\///g' -e 's/.qc.bam//g' | gzip > ''' + output.gzcall
		os.system(finalcmd)
		
rule make_depth_table:
	input:
		expand(outdir + "/qc/depth/{sample}.Q0.depth.txt", sample=SAMPLES)
	output:
		outdir + "/final/" + name + ".depthTable.txt"
	threads: 1
	run: 
		with open(output[0], 'w') as f:
			for i in input:
				sample = i.replace(outdir+ "/qc/depth/", '').replace(".Q0.depth.txt", '')
				result = subprocess.run(['cat', i], stdout=subprocess.PIPE)
				f.write(sample + " " + result.stdout.strip().decode("utf-8") + "\n")
